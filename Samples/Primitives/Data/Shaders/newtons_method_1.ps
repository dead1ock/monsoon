////////////////////////////////////////////////////////////////////////////////
// Filename: texture.ps
////////////////////////////////////////////////////////////////////////////////

#define complex float2

float real(complex a) {
	return a.x;	
}

complex conj(complex a) {
	return complex(a.x, -a.y);	
}

complex complex_mul(complex a, complex b) {
	return complex(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);	
}

complex complex_div(complex a, complex b) {
	return complex_mul(a,conj(b)) / real(complex_mul(b, conj(b)));
}

complex f(complex z) {
	return complex_mul(complex_mul(z, z), complex_mul(z, z)) - (sin(z)*sin(z));
}

complex f_prime(complex z) {
	return 4.0 * complex_mul(z, complex_mul(z,z)) - (2 * cos(z));
}

complex newtonsMethod(complex z) {
	return z - complex_div(complex_mul(z,complex_mul(z,z)) - complex(1.0,0.0), f_prime(z));	
}

float4 sampleColor(complex z) {
	return float4(sin(z.x*100.0)*0.5+0.5, sin(z.y*100.0)*0.5+0.5, sin((z.x+z.y)*100.0)*0.5+0.5, 1);
}

//////////////
// TYPEDEFS //
//////////////
struct PixelInputType
{
    float4 position : SV_POSITION;
    float2 tex : TEXCOORD0;
};

////////////////////////////////////////////////////////////////////////////////
// Pixel Shader
////////////////////////////////////////////////////////////////////////////////
float4 TexturePixelShader(PixelInputType input) : SV_TARGET
{	
	complex z = complex(input.tex.x - 0.5, input.tex.y - 0.5);
	for(int i = 0; i <100; ++i) {
		z = newtonsMethod(z);
	}
	
	return sampleColor(z);
}

